/**
 * Script to download real TMDB data for offline development
 * Run with: node scripts/download-tmdb-mock-data.js
 */

const fs = require('fs');
const path = require('path');

const API_KEY = '0fb4e9596ba87e55fbecedb882f9500b';
const BASE_URL = 'https://api.themoviedb.org/3';

async function fetchFromTMDB(endpoint) {
  const url = `${BASE_URL}/${endpoint}${endpoint.includes('?') ? '&' : '?'}api_key=${API_KEY}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status}`);
  }
  return response.json();
}

async function downloadMovies() {
  console.log('Downloading movies...');

  // Fetch popular, trending, now playing, top rated
  const [popular, trending, nowPlaying, topRated] = await Promise.all([
    fetchFromTMDB('movie/popular?page=1'),
    fetchFromTMDB('trending/movie/day'),
    fetchFromTMDB('movie/now_playing?page=1'),
    fetchFromTMDB('movie/top_rated?page=1'),
  ]);

  // Combine and dedupe to get ~50 unique movies
  const allMovies = new Map();
  [...popular.results, ...trending.results, ...nowPlaying.results, ...topRated.results].forEach(movie => {
    allMovies.set(movie.id, movie);
  });

  // Get detailed info for top 50
  const movieIds = Array.from(allMovies.keys()).slice(0, 50);
  console.log(`Fetching details for ${movieIds.length} movies...`);

  const detailedMovies = [];
  for (const id of movieIds) {
    try {
      const details = await fetchFromTMDB(`movie/${id}?append_to_response=credits,videos,images`);
      detailedMovies.push(details);
      process.stdout.write('.');
    } catch (error) {
      console.error(`Failed to fetch movie ${id}:`, error.message);
    }
  }
  console.log('\n');

  return {
    movies: detailedMovies,
    popular: popular.results.slice(0, 20),
    trending: trending.results.slice(0, 20),
    nowPlaying: nowPlaying.results.slice(0, 20),
    topRated: topRated.results.slice(0, 20),
  };
}

async function downloadTvShows() {
  console.log('Downloading TV shows...');

  const [popular, trending, airingToday, topRated] = await Promise.all([
    fetchFromTMDB('tv/popular?page=1'),
    fetchFromTMDB('trending/tv/day'),
    fetchFromTMDB('tv/airing_today?page=1'),
    fetchFromTMDB('tv/top_rated?page=1'),
  ]);

  // Combine and dedupe
  const allShows = new Map();
  [...popular.results, ...trending.results, ...airingToday.results, ...topRated.results].forEach(show => {
    allShows.set(show.id, show);
  });

  // Get detailed info for top 50
  const showIds = Array.from(allShows.keys()).slice(0, 50);
  console.log(`Fetching details for ${showIds.length} TV shows...`);

  const detailedShows = [];
  for (const id of showIds) {
    try {
      const details = await fetchFromTMDB(`tv/${id}?append_to_response=credits,videos,images`);
      detailedShows.push(details);
      process.stdout.write('.');
    } catch (error) {
      console.error(`Failed to fetch TV show ${id}:`, error.message);
    }
  }
  console.log('\n');

  return {
    shows: detailedShows,
    popular: popular.results.slice(0, 20),
    trending: trending.results.slice(0, 20),
    airingToday: airingToday.results.slice(0, 20),
    topRated: topRated.results.slice(0, 20),
  };
}

async function downloadPeople() {
  console.log('Downloading people...');

  const popular = await fetchFromTMDB('person/popular?page=1');

  // Get detailed info for top 20 people
  const peopleIds = popular.results.slice(0, 20).map(p => p.id);

  const detailedPeople = [];
  for (const id of peopleIds) {
    try {
      const details = await fetchFromTMDB(`person/${id}?append_to_response=movie_credits,tv_credits,images`);
      detailedPeople.push(details);
      process.stdout.write('.');
    } catch (error) {
      console.error(`Failed to fetch person ${id}:`, error.message);
    }
  }
  console.log('\n');

  return {
    people: detailedPeople,
    popular: popular.results.slice(0, 20),
  };
}

async function downloadGenres() {
  console.log('Downloading genres...');

  const [movieGenres, tvGenres] = await Promise.all([
    fetchFromTMDB('genre/movie/list'),
    fetchFromTMDB('genre/tv/list'),
  ]);

  return { movieGenres: movieGenres.genres, tvGenres: tvGenres.genres };
}

function generateMoviesFile(data) {
  return `/**
 * Real TMDB movie data for offline development
 * Auto-generated by scripts/download-tmdb-mock-data.js
 * Generated at: ${new Date().toISOString()}
 */

// Detailed movie data (with credits, videos, images)
export const mockMovieDetails: Record<number, any> = ${JSON.stringify(
    data.movies.reduce((acc, movie) => ({ ...acc, [movie.id]: movie }), {}),
    null, 2
  )};

// List data for various endpoints
export const mockMoviesPopular = ${JSON.stringify(data.popular, null, 2)};
export const mockMoviesTrending = ${JSON.stringify(data.trending, null, 2)};
export const mockMoviesNowPlaying = ${JSON.stringify(data.nowPlaying, null, 2)};
export const mockMoviesTopRated = ${JSON.stringify(data.topRated, null, 2)};

// Helper functions
export const getTrendingMovies = () => ({
  page: 1,
  results: mockMoviesTrending,
  total_pages: 1,
  total_results: mockMoviesTrending.length,
});

export const getPopularMovies = () => ({
  page: 1,
  results: mockMoviesPopular,
  total_pages: 1,
  total_results: mockMoviesPopular.length,
});

export const getNowPlayingMovies = () => ({
  page: 1,
  results: mockMoviesNowPlaying,
  total_pages: 1,
  total_results: mockMoviesNowPlaying.length,
});

export const getTopRatedMovies = () => ({
  page: 1,
  results: mockMoviesTopRated,
  total_pages: 1,
  total_results: mockMoviesTopRated.length,
});

export const getMovieById = (id: number): any | undefined => {
  return mockMovieDetails[id] || Object.values(mockMovieDetails)[0];
};

export const mockMovies = Object.values(mockMovieDetails);
`;
}

function generateTvShowsFile(data) {
  return `/**
 * Real TMDB TV show data for offline development
 * Auto-generated by scripts/download-tmdb-mock-data.js
 * Generated at: ${new Date().toISOString()}
 */

// Detailed TV show data (with credits, videos, images)
export const mockTvDetails: Record<number, any> = ${JSON.stringify(
    data.shows.reduce((acc, show) => ({ ...acc, [show.id]: show }), {}),
    null, 2
  )};

// List data for various endpoints
export const mockTvPopular = ${JSON.stringify(data.popular, null, 2)};
export const mockTvTrending = ${JSON.stringify(data.trending, null, 2)};
export const mockTvAiringToday = ${JSON.stringify(data.airingToday, null, 2)};
export const mockTvTopRated = ${JSON.stringify(data.topRated, null, 2)};

// Helper functions
export const getTrendingTv = () => ({
  page: 1,
  results: mockTvTrending,
  total_pages: 1,
  total_results: mockTvTrending.length,
});

export const getPopularTv = () => ({
  page: 1,
  results: mockTvPopular,
  total_pages: 1,
  total_results: mockTvPopular.length,
});

export const getAiringToday = () => ({
  page: 1,
  results: mockTvAiringToday,
  total_pages: 1,
  total_results: mockTvAiringToday.length,
});

export const getTopRatedTv = () => ({
  page: 1,
  results: mockTvTopRated,
  total_pages: 1,
  total_results: mockTvTopRated.length,
});

export const getTvShowById = (id: number): any | undefined => {
  return mockTvDetails[id] || Object.values(mockTvDetails)[0];
};

export const mockTvShows = Object.values(mockTvDetails);

// Season details mock (generates fake episodes based on season info in show data)
export const getSeasonDetails = (tvId: number, seasonNumber: number) => {
  const show = getTvShowById(tvId);
  if (!show) return null;

  const season = show.seasons?.find((s: any) => s.season_number === seasonNumber);
  if (!season) return null;

  // Generate mock episodes
  const episodes = Array.from({ length: season.episode_count || 10 }, (_, i) => ({
    id: tvId * 1000 + seasonNumber * 100 + i + 1,
    name: \`Episode \${i + 1}\`,
    overview: \`Episode \${i + 1} of season \${seasonNumber}.\`,
    episode_number: i + 1,
    season_number: seasonNumber,
    air_date: season.air_date,
    runtime: 45,
    still_path: show.backdrop_path,
    vote_average: 7.5,
    vote_count: 100,
  }));

  return {
    ...season,
    episodes,
  };
};
`;
}

function generatePeopleFile(data) {
  return `/**
 * Real TMDB people data for offline development
 * Auto-generated by scripts/download-tmdb-mock-data.js
 * Generated at: ${new Date().toISOString()}
 */

// Detailed person data (with credits, images)
export const mockPersonDetails: Record<number, any> = ${JSON.stringify(
    data.people.reduce((acc, person) => ({ ...acc, [person.id]: person }), {}),
    null, 2
  )};

export const mockPeoplePopular = ${JSON.stringify(data.popular, null, 2)};

export const getPersonById = (id: number): any => {
  return mockPersonDetails[id] || Object.values(mockPersonDetails)[0];
};

export const getPersonMovieCredits = (personId: number) => {
  const person = getPersonById(personId);
  return person?.movie_credits || { cast: [], crew: [] };
};

export const getPersonTvCredits = (personId: number) => {
  const person = getPersonById(personId);
  return person?.tv_credits || { cast: [], crew: [] };
};

export const getPersonImages = (personId: number) => {
  const person = getPersonById(personId);
  return person?.images || { profiles: [] };
};

export const searchPerson = (query: string) => {
  const lowerQuery = query.toLowerCase();
  const results = mockPeoplePopular.filter((p: any) =>
    p.name.toLowerCase().includes(lowerQuery)
  );
  return {
    page: 1,
    results: results.length > 0 ? results : mockPeoplePopular.slice(0, 5),
    total_pages: 1,
    total_results: results.length || 5,
  };
};
`;
}

function generateGenresFile(data) {
  return `/**
 * Real TMDB genre data for offline development
 * Auto-generated by scripts/download-tmdb-mock-data.js
 * Generated at: ${new Date().toISOString()}
 */

export const movieGenres = ${JSON.stringify(data.movieGenres, null, 2)};

export const tvGenres = ${JSON.stringify(data.tvGenres, null, 2)};

export const getMovieGenres = () => ({ genres: movieGenres });
export const getTvGenres = () => ({ genres: tvGenres });
`;
}

async function main() {
  console.log('Starting TMDB data download...\n');

  try {
    const [movieData, tvData, peopleData, genreData] = await Promise.all([
      downloadMovies(),
      downloadTvShows(),
      downloadPeople(),
      downloadGenres(),
    ]);

    const mocksDir = path.join(__dirname, '..', 'lib', 'mocks', 'tmdb');

    // Ensure directory exists
    if (!fs.existsSync(mocksDir)) {
      fs.mkdirSync(mocksDir, { recursive: true });
    }

    console.log('Writing files...');

    fs.writeFileSync(
      path.join(mocksDir, 'movies.ts'),
      generateMoviesFile(movieData)
    );
    console.log('  - movies.ts');

    fs.writeFileSync(
      path.join(mocksDir, 'tv-shows.ts'),
      generateTvShowsFile(tvData)
    );
    console.log('  - tv-shows.ts');

    fs.writeFileSync(
      path.join(mocksDir, 'people.ts'),
      generatePeopleFile(peopleData)
    );
    console.log('  - people.ts');

    fs.writeFileSync(
      path.join(mocksDir, 'genres.ts'),
      generateGenresFile(genreData)
    );
    console.log('  - genres.ts');

    console.log('\nDone! Downloaded:');
    console.log(`  - ${movieData.movies.length} movies with details`);
    console.log(`  - ${tvData.shows.length} TV shows with details`);
    console.log(`  - ${peopleData.people.length} people with details`);
    console.log(`  - ${genreData.movieGenres.length} movie genres`);
    console.log(`  - ${genreData.tvGenres.length} TV genres`);

  } catch (error) {
    console.error('Error downloading TMDB data:', error);
    process.exit(1);
  }
}

main();
